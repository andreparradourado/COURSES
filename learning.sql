/* LONG COMMENT TYPE */
-- SINGLE LINE COMMENT TYPE

---------------------- \\ ----------------------

-- NEVER TYPE DIRECTLY IN THE MYSQL, FIRST DO IT IN THE IDE/EDITOR AND CHECK !
-- MYSQL SERVICE MUST BE RUNNING TO ENTER THE DBMS
-- MYSQL WILL BE CASE SENSITIVE IF THE O.S IS CASE SENSITIVE.
-- MYSQL USES ANSI SQL WITH SOME MINOR MODIFICATIONS
-- WINDOWS -> NOT CASE SENSITIVE
-- LINUX -> CASE SENSITIVE

---------------------- \\ ----------------------

-- BASIC MODELING - CONCEITUAL MODELING
-- CLIENTE TABLE
NOME - CARACTER(30)
CPF - NUMERICO(11)
EMAIL - CARACTER(30)
TELEFONE - CARACTER(30)
ENDEREÇO - CARACTER(100)
SEXO - CARACTER(1)

---------------------- \\ ----------------------

-- FIRST COMMANDS
SHOW DATABASES;           -- PRINTS THE SGBD DATABASES
STATUS                    -- PRINTS THE CURRENT CONNECTED DATABASE
SYSTEM CLS                -- CLEARS THE TERMINAL SCREEN
CREATE DATABASE PROJETO;  -- CREATES A DATABASE NAMED "PROJETO"
USE PROJETO;              -- CONNECTS TO THE DATABASE "PROJETO"
SHOW TABLES;              -- PRINTS THE TABLES OF THE CURRENT CONNECTED DATABASE

---------------------- \\ ----------------------

-- CREATES A TABLE NAMED CLIENTE WITH 6 COLUMNS, EACH ONE SPECIFIED BY DATA TYPE
CREATE TABLE CLIENTE(
	NOME VARCHAR(30),
	SEXO CHAR(1),
	EMAIL VARCHAR(30),
	CPF INT(11),
	TELEFONE VARCHAR(30),
	ENDERECO VARCHAR(100)
);

-- IT'S NOT RECOMMENDED TO HAVE SPACES BETWEEN THE COLUMN'S NAME

DESC CLIENTE; -- DESCRIBES THE STRUCTURE OF THE TABLE "CLIENTE"

---------------------- \\ ----------------------

-- DATA INSERTION MANNERS

-- 1° INSERTION SYNTAX MANNER - INSERT INTO TABLE_NAME VALUES(VALUE1,VALUE2,VALUE3)...
-- OMITTING THE COLUMNS - THE VALUES INSERTED MUST FOLLOW THE TABLE'S COLUMNS ORDER
INSERT INTO CLIENTE VALUES('JOAO', 'M', 'JOAO@GMAIL.COM', 988638273, '22923110', 'MAIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ');
INSERT INTO CLIENTE VALUES('CELIA', 'F', 'CELIA@GMAIL.COM', 541521456, '25078869', 'RIACHUELO - CENTRO - RIO DE JANEIRO - RJ');
INSERT INTO CLIENTE VALUES('JORGE', 'M', NULL, 885755896, '58748895', 'OSCAR CURY - BOM RETIRO - PATOS DE MINAS - MG');

-- 2° INSERTION SYNTAX MANNER - INSERT INTO TABLE_NAME(COLUMNNAMEz, COLUMNNAMEy, COLUMNAMEz) VALUES (VALUEx, VALUEy, VALUEz)
-- SPECIFIYING THE COLUMNS - FOLLOWS THE DIGITATED COLUMNS ORDER
INSERT INTO CLIENTE(NOME, SEXO, ENDERECO, TELEFONE, CPF) VALUES ('LILIAN', 'F', 'SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ', '947785696', 887774856);

-- 3ª INSERTION SYNTAX MANNER - COMPACT INSERT - ONLY MYSQL
INSERT INTO CLIENTE VALUES
('ANA', 'F', 'ANA@GLOBO.COM', 85548962, '548556985', 'PRES ANTONIO CARLOS - CENTRO - SAO PAULO - SP'),
('CARLA', 'F', 'CARLA@TERATI.COM.BR', 7745828, '66587458', 'SAMUEL SILVA - CENTRO - BELO HORIZONTE - MG');

---------------------- \\ ----------------------

-- QUERY EXPLANATION
-- SELECT COMMAND
-- SELECTION, PROJECTION AND JOINT
 
-- EXAMPLE OF A FUNCTION ON THE DATABASE
NOW(); -- PRINTS THE TIMESTAMP

-- BUILDING DATA 
SELECT NOW ();            -- PROJECTS THE TIMESTAMP ON THE SCREEN UNDER THE COLUMN NOW()
SELECT 'ANY_INFORMATION'; -- PROJECTS "ANYINFORMATION" ON THE SCREEN AS THE TABLE COLUMN AND AS THE TABLE FIELD

-- COLUMNS ALIAS USAGE
SELECT NOW() AS DATA_HORA;                   -- PROJECT THE TIMESTAMP WITH A COLUMN NAMED DATA_HORA
SELECT 'ANY_FIELD_VALUE' AS ANY_COLUMN_NAME; -- PROJECTS "ANY_DATA_NAME" AS A FIELD VALUE FOR THE "ANY_COLUMN_NAME" COLUMN

-- PROJECTING DATABASE TABLE INFO - PROJECTION
SELECT NOME, SEXO, EMAIL FROM CLIENTE;
SELECT NOME AS CLIENTE, SEXO, EMAIL FROM CLIENTE; -- WITH ALIAS IN THE FIRST COLUMN
SELECT EMAIL, SEXO, ENDERECO, NOME FROM CLIENTE;  -- IN A DIFFERENT SEQUENCE
SELECT EMAIL, SEXO, ENDERECO, NOME, NOW() AS DATA_HORA FROM CLIENTE;

-- JUST FOR ACADEMIC PURPOSE - SELECT * FROM TABLE - PROJECT EVERYTHING FROM A TABLE
SELECT * FROM CLIENTE;

-- ONLY PROJECT THE REQUESTED DATA OTHERWISE UNNECESSARY PROCESSING WILL BE DEMANDED
-- FULL SCAN WILL BE USED ONLY IN SPECIFIC SIUATIONS

---------------------- \\ ----------------------

-- FILTERS
-- SELECT IS A WAY TO FILTER BY COLUMNS - IT'S A PART OF THE PROJECTION
-- THE GENERAL FILTERS FILTER BY REGISTERS, NOT COLUMNS

-- PROJECTION USES -> SELECT COMMAND
-- SELECTION USES  -> WHERE COMMAND

-- SELECTION
-- FILTERING WITH WHERE - IT DOESN'T NEED THE PROJECTION TO FILTER BY THE CONDITION, IT JUST SELECTS BY THE CONDITION
SELECT NOME, SEXO 
FROM CLIENTE
WHERE SEXO = 'F';

SELECT NOME, ENDERECO 
FROM CLIENTE
WHERE SEXO = 'F';

SELECT NOME, SEXO 
FROM CLIENTE
WHERE ENDERECO = 'RJ';

/* 
EQUAL(=) != LIKE
"EQUAL" MEANS EXACTLY THE SAME THING, ON THE OTHER HAND "LIKE" SEARCHS SIMILARITIES
"LIKE" USES THE CHARACTER % TO SPECIFY THE SELECTION 
%VALUE = VALUE IN THE DATA END 
VALUE% = VALUE IN THE DATA BEGINNING 
%VALUE% = ANYWHERE AMONG THE DATA 
UNDERLINE MAKE IT MORE SPECIFIC LIKE %____XX%, BUT LOSES PERFORMANCE
*/ 

SELECT NOME, ENDERECO 
FROM CLIENTE
WHERE ENDERECO LIKE 'SAMUEL%';

SELECT NOME, ENDERECO 
FROM CLIENTE
WHERE ENDERECO LIKE '%CENTRO%';

SELECT NOME, ENDERECO 
FROM CLIENTE
WHERE ENDERECO LIKE '%RJ';

---------------------- \\ ----------------------

-- EXERCISE 1 - LIVRARIA
CREATE DATABASE LIVRARIA;

USE LIVRARIA;

CREATE TABLE LIVROS(
	NOME_DO_LIVRO VARCHAR(50),
	NOME_DO_AUTOR VARCHAR(30),
	SEXO_DO_AUTOR CHAR(1),
	NUMERO_DE_PAGINAS INT(4),
	NOME_DA_EDITORA VARCHAR(30),
	VALOR_DO_LIVRO FLOAT(6,2),
	UF CHAR (2),
	ANO_DA_PUBLICACAO INT(5)
);

DESC LIVROS;

INSERT INTO LIVROS(NOME_DO_LIVRO, NOME_DO_AUTOR, SEXO_DO_AUTOR, NUMERO_DE_PAGINAS, NOME_DA_EDITORA, VALOR_DO_LIVRO, UF, ANO_DA_PUBLICACAO) VALUES
('CAVALEIRO REAL', 'ANA CLAUDIA', 'F', 465, 'ATLAS', 49.9, 'RJ', 2009),
('SQL PARA LEIGOS', 'JOAO NUNES', 'M', 450,'ADDISON', 98, 'SP', 2018),
('RECEITAS CASEIRAS', 'CELIA TAVARES', 'F', 210, 'ATLAS', 45, 'RJ', 2008),
('PESSOAS EFETIVAS', 'EDUARDO SANTOS', 'M', 390, 'BETA', 78.99, 'RJ', 2018),
('HABITOS SAUDAVEIS', 'EDUARDO SANTOS', 'M', 630, 'BETA', 150.98, 'RJ', 2019),
('A CASA MARROM', 'HERMES MACEDO', 'M', 250, 'BUBBA', 60, 'MG', 2016),
('ESTACIO QUERIDO', 'GERALDO FRANCISCO', 'M', 310, 'INSIGNIA', 100, 'ES', 2015),
('PRA SEMPRE AMIGAS', 'LEDA SILVA', 'F', 510, 'INSIGNIA', 78.98, 'ES', 2011),
('COPAS INESQUECIVEIS', 'MARCO ALCANTARA', 'M', 200, 'LARSON', 130.98, 'RS', 2018),
('O PODER DA MENTE', 'CLARA MAFRA', 'F', 120, 'CONTINENTAL', 56.58, 'RS', 2017);

-- 1 - TRAZER TODOS OS DADOS
SELECT * FROM LIVROS;

-- 2 - TRAZER O NOME DO LIVRO E O NOME DA EDITORA
SELECT NOME_DO_LIVRO, NOME_DA_EDITORA 
FROM LIVROS;

-- 3 - TRAZER O NOME DO LIVRO E A UF DOS LIVROS PUBLICADOS POR AUTORES DO SEXO MASCULINO
SELECT NOME_DO_LIVRO, UF 
FROM LIVROS
WHERE SEXO_DO_AUTOR = 'M';

-- 4 - TRAZER O NOME DO LIVRO E O NÚMERO DE PÁGINAS DOS LIVROS PUBLICADOS POR AUTORES DO SEXO FEMINIMO
SELECT NOME_DO_LIVRO, NUMERO_DE_PAGINAS 
FROM LIVROS
WHERE SEXO_DO_AUTOR ='F';

-- 5 - TRAZER OS VALORES DOS LIVROS DAS EDITORAS DE SÃO PAULO
SELECT VALOR_DO_LIVRO 
FROM LIVROS
WHERE UF ='SP';

-- 6 - TRAZER OS DADOS DOS AUTORES DO SEXO MASCULINO QUE TIVERAM LIVROS PUBLICADOS POR SÃO PAULO OU RIO DE JANEIRO (QUESTÃO DESAFIO)
SELECT * FROM LIVROS
WHERE SEXO_DO_AUTOR ='M'
AND (UF ='SP' OR UF='RJ');

---------------------- \\ ----------------------

-- EXAMPLE OF ARITMETICAL OPERATOR
SELECT * FROM LIVROS
WHERE SEXO_DO_AUTOR = 'M'
AND (NUMERO_DE_PAGINAS > 300);

---------------------- \\ ----------------------

-- LOGIC GATES - LOGICAL OPERATORS
-- OR  -> FOR THE QUERY TO BE TRUE IT JUST NEEDS ONE CONDITION TO BE TRUE
-- AND -> FOR THE QUERY TO BE TRUE IT NEEDS ALL THE CONDITIONS TO BE TRUE

-- USING LOGIC GATE "OR" 
SELECT NOME, SEXO, ENDERECO 
FROM CLIENTE
WHERE (SEXO ='M' OR ENDERECO LIKE '%RJ');

SELECT NOME, SEXO, ENDERECO 
FROM CLIENTE
WHERE (SEXO = 'F' OR ENDERECO LIKE '%ESTACIO');

-- USING LOGIC GATE "AND"
SELECT NOME, SEXO, ENDERECO 
FROM CLIENTE
WHERE (SEXO = 'M' AND ENDERECO LIKE '%RJ');

SELECT NOME, SEXO, ENDERECO 
FROM CLIENTE
WHERE (SEXO = 'F' AND ENDERECO LIKE '%ESTACIO');

---------------------- \\ ----------------------

-- COUNT (*), GROUP BY, PERFORMANCE WITH LOGIC OPERATORS

-- COUNTING THE TABLE'S REGISTERS
SELECT COUNT(*) AS "QTD DE REGISTROS" 
FROM CLIENTE;

SELECT COUNT(*) AS BANANA 
FROM CLIENTE;

-- THE GROUP BY OPERATOR
SELECT SEXO, COUNT(*) FROM CLIENTE; -- ERRADO, A FUNÇÃO COUNT LIMITA A BUSCA

SELECT * FROM CLIENTE;

SELECT SEXO, COUNT(*) 
FROM CLIENTE
GROUP BY SEXO; 
-- COUNTING THE WHOLE DATABASE AND GROUPING BY SOMETHING THAT ISN'T ON THE FUNCTION, IN THIS CASE BY "SEX"
-- 6/SEXO DISTRIBUTING BY "MALE" AND "FEMALE"

-- PERFORMANCE IN LOGIC OPERATORS

-- TO COUNT ALL ROWS
SELECT COUNT(*) 
FROM CLIENTE;

SELECT SEXO, COUNT(*) 
FROM CLIENTE
GROUP BY SEXO;

SELECT CIDADE, COUNT(*) 
FROM CLIENTE
GROUP BY CIDADE;

/* 
CONDICAO -> SEXO = F OU CIDADE = RJ
SITUAÇÃO - TRATANDO COM OU/OR
70% DA TABELA SÃO MULHERES = SEXO = F
30% DA TABELA MORA NO RJ
É MAIS FACIL COLOCAR AS MULHERES NA FRENTE PARA A CHECAGEM SER MAIS RÁPIDA
*/

SELECT NOME, SEXO, ENDERECO
FROM CLIENTE
WHERE (SEXO ='F' OR CIDADE ='RJ');

/*
CONDICAO -> SEXO = F E CIDADE = RJ
SITUACAO - TRATANDO COM E/AND
70% DA TABELA SÃO MULHERES = SEXO = F
30% DA TABELA MORA NO RJ
É MAIS FACIL COLOCAR A PRIMEIRA CONDIÇÃO NA FRENTE POIS ELA TEM VOLUME MENOR E ELA SÓ IRA TESTAR A SEGUNDA CONDIÇÃO CASO ENTRE NESSA MINORIA
*/

SELECT NOME, SEXO, ENDERECO
FROM CLIENTE
WHERE (CIDADE ='RJ' AND SEXO ='F');

---------------------- \\ ----------------------

-- EXERCICIOS 31.26

SELECT COUNT(*) FROM FUNCIONARIOS;
-- COUNTOU 975 FUNCIONARIOS

SELECT COUNT(*), DEPARTAMENTO
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO
ORDER BY 1;
/*
+----------+---------------+
| COUNT(*) | DEPARTAMENTO  |
+----------+---------------+
|       21 | Filmes        |
|       36 | Joalheria     |
|       37 | Música        |
|       38 | Crianças      |
|       39 | Ferramentas   |
|       40 | Esporte       |
|       41 | Brinquedos    |
|       43 | Calçados      |
|       45 | Bebês         |
|       46 | Automotivo    |
|       46 | Alimentícios  |
|       46 | Saúde         |
|       47 | Industrial    |
|       47 | Jardim        |
|       47 | Books         |
|       48 | Outdoors      |
|       49 | Games         |
|       49 | Eletronicos   |
|       52 | Computadores  |
|       52 | Lar           |
|       53 | Roupas        |
|       53 | Beleza        |
+----------+---------------+
22 rows in set (0.00 sec)
*/

-- 1 - TRAZER OS FUNCIONÁRIOS QUE TRABALHAM NO DEPARTAMENTO DE FILMES OU NO DEPARTAMENTOS DE ROUPAS 
-- COM O OR COLOCAR NA PRIMEIRA CONDIÇÃO O MAIS PROVÁVEL DE SATISFAZER, POIS ECONOMIZARÁ PROCESSAMENTO
SELECT COUNT(*)
FROM FUNCIONARIOS
WHERE (DEPARTAMENTO = 'FILMES' OR DEPARTAMENTO = 'ROUPAS');
-- CONTOU 74 FUNCIONÁRIOS DESSES 2 SETORES

SELECT NOME, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE (DEPARTAMENTO = 'ROUPAS' OR DEPARTAMENTO = 'FILMES');

/*
2 - O GESTOR DE MARKETING PEDIU A LISTA DAS FUNCIONARIAS QUE TRABALHEM NO DEPARTAMENTO DE FILMES 
OU NO DEPARTAMENTO LAR. ELE NECESSITA ENVIAR UM EMAIL PARA AS COLABORADORAS DESSES DOIS SETORES.
*/
SELECT COUNT(*), SEXO
FROM FUNCIONARIOS
GROUP BY SEXO;
-- 491 FEMIMNINO E 484 MASCULINO

SELECT COUNT(*), DEPARTAMENTO
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO;
-- FILMES = 21, LAR = 52 

-- ANDRÉ'S APPROACH -> (A + B) * C
SELECT NOME, EMAIL, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE 
(DEPARTAMENTO ='LAR' OR DEPARTAMENTO ='FILMES')
AND 
(SEXO ='FEMININO');

-- MAFRA'S APPROACH -> (A*C)+(B*C)
SELECT NOME, EMAIL, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE 
(DEPARTAMENTO ='LAR' AND SEXO ='FEMININO')
OR 
(DEPARTAMENTO ='FILMES' AND SEXO ='FEMININO');

-- COMO ESTAMOS TRABALHANDO COM AND, COLOCAMOS O DEPARTAMENTO PRIMEIRO POIS ELE IRÁ CHECAR A SEGUNDA CONDIÇÃO UM NUMERO MENOR DE VEZES

-- 4 - TRAGA OS FUNCIONARIOS DO SEXO MASCULINO OU OS FUNCIONARIOS QUE TRABALHAM NO JARDIM
SELECT NOME, SEXO, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE (SEXO = 'MASCULINO');

SELECT NOME, SEXO, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE (DEPARTAMENTO ='JARDIM');

SELECT NOME, SEXO, DEPARTAMENTO
FROM FUNCIONARIOS
WHERE (SEXO = 'MASCULINO' OR DEPARTAMENTO ='JARDIM');
-- 507 RESULTS

---------------------- \\ ----------------------

-- FILTERING NULL VALUES
SELECT * FROM CLIENTE
WHERE EMAIL IS NULL;

SELECT * FROM CLIENTE
WHERE EMAIL IS NOT NULL;

-- NEVER USE "SOMETHING = NULL"

---------------------- \\ ----------------------

-- UPDATE CLAUSE
SELECT NOME, EMAIL
FROM CLIENTE
WHERE EMAIL IS NULL;

UPDATE CLIENTE
SET EMAIL ='LILIAN@HOTMAIL.COM'; -- IF YOU USE THE UPDATE CLAUSE WITH THIS APPROACH IT WILL UPDATE **ALL** FIELDS OF THE EMAIL COLUMN

SELECT * FROM CLIENTE;

SELECT * FROM CLIENTE
WHERE NOME ='LILIAN';

UPDATE CLIENTE
SET EMAIL = 'LILIAN@HOTMAIL.COM'
WHERE NOME = 'LILIAN';

UPDATE CLIENTE
SET EMAIL = 'JOAO@IG.COM.BR'
WHERE NOME = 'JOAO';

UPDATE CLIENTE
SET EMAIL = 'JORGE@IG.COM.BR'
WHERE NOME = 'JORGE';

---------------------- \\ ----------------------

-- DELETE CLAUSE
-- DELETING REGISTERS WITH THE DELETE CLAUSE

DELETE FROM CLIENTE; -- IT WILL CLEAN ALL THE TABLE'S REGISTERS

SELECT * FROM FUNCIONARIOS 
WHERE NOME ='ANA';

SELECT COUNT(*) FROM CLIENTE; -- TOTAL 6 

SELECT COUNT(*) FROM CLIENTE
WHERE NOME = 'ANA';           -- 1

DELETE FROM CLIENTE
WHERE NOME = 'ANA';

SELECT COUNT(*) FROM CLIENTE; -- 5 LEFT

SELECT 6-1; -- EXECUTE THE CAlCULATION AND PRINTS THE RESULT

SELECT * FROM CLIENTE;

INSERT INTO CLIENTE VALUES ('CARLA', 'F', 'CLOPES@UOL.COM', 45638854, '4575-0048','RUA COPPER LEAF - WILLIAMSBURG - KITCHENER');

-- TO BE SURE, ALWAYS DO THE SELECT BEFORE DELETING
-- SWITCH "DELETE" BY "SELECT" AND IT WILL PRINT WHAT WOULD BE DELETED WITH THE DELETE COMMAND

SELECT * FROM CLIENTE
WHERE NOME = 'CARLA'
OR EMAIL = 'LILIAN@HOTMAIL.COM';

DELETE FROM CLIENTE
WHERE NOME = 'CARLA'
OR EMAIL = 'LILIAN@HOTMAIL.COM';

SELECT * FROM CLIENTE
WHERE 
(NOME ='CARLA' AND EMAIL ='LILIAN@HOTMAIL.COM');

DELETE FROM CLIENTE
WHERE 
(NOME ='CARLA' AND EMAIL ='LILIAN@HOTMAIL.COM');
-- /\ JUST USE THE DELETE COMMAND WHEN THE SELECT COMMAND RETURNS THE RIGHT RESULT. /\

SELECT COUNT(*)        -- IT GROUPS BY GENDER BUT DOESN'T SHOW WHICH IS WHICH
FROM CLIENTE
GROUP BY SEXO;

SELECT SEXO, COUNT(*)  -- IT GROUPS BY GENDER AND IDENTIFIES THEM
FROM CLIENTE 
GROUP BY SEXO;

SELECT ENDERECO, COUNT(*)
FROM CLIENTE
GROUP BY ENDERECO;

---------------------- \\ ----------------------

-- DATABASE NORMALIZATION
-- THERE ARE 5 NORMAL FORMS OF WHICH 3 ARE ENOUGH TO CREATE A CLEAN, ORGANIZED AND ERRORLESS WORK

-- 1ª NORMAL FORM - IT HAS 3 RULES

-- 1ª RULE: ALL VECTORIZED FIELD WILL BECOME ANOTHER TABLE
-- THERE IS COHERENCE IN THE VECTORS VALUES, EXAMPLES BELOW:
-- (YELLOW, BLUE, ORANGE, GREEN) -> COLOR VECTOR
-- (KA, FIESTA, UNO, CIVID) -> CAR VECTOR

-- 2ª RULE: ALL MULTIVALUED FIELD WILL BECOME ANOTHER TABLE
-- IN OTHER WORDS, IT'S WHEN THE FIELD IS DIVISIBLE

-- 3ª RULE: EVERY TABLE NEEDS AT LEAST ONE FIELD THAT IDENTIFIES EACH REGISTER AS UNIQUE, THIS FIELD IS USUALLY CALLED PRIMARY KEY
-- CPF AND SUCHLIKE INFORMATION DON'T SERVE TO BE THE PRIMARY KEY BECAUSE THEY WEREN'T MADE FOR DATABASE PURPOSE AND THEY CAN BE ALTERED WITHOUT OUR CONSENT, AFFECTING ALL THE DATABASE
-- THE DATABASE HAS TO HAVE ITS OWN ID'S.

-- THERE 2 TYPE OF PRIMARY KEYS
-- 1º NATURAL KEY -> IT REALLY BELONGS TO THE REGISTER (AS "CPF")
-- 2° ARTIFICIAL KEY -> IT IS CREATED, USUALLY STAYS IN THE TABLE'S FIRST COLUMN

-- ALTHOUGH THE NATURAL KEY INCREASES THE COHESION, AND THE ARTIFICIAL KEY BEING HARDER TO COMPREHEND, USING THE KEY ARTIFICIAL KEY IS MUCH WAY BETTER WHEN WE ARE TALKING ABOUT THE DATABASE GROWTH

-- APPLYING THE 1º NORMAL FORM IN THE BRMODELO

-- CARDINALITY AND OBLIGATORINESS
-- THE BUSINESS RULES DEFINE THE CARDINALITY, NOT THE PROGRAMMERS.

-- ENDERECO: OBRIGATORIO O CADASTRO DE UM ENDEREÇO -> (1,1)
-- TELEFONE: O CLIENTE NÃO É OBRIGADO A FORNECER PORÉM SE QUISER PODE FORNECER MAIS DE 1 -> (0,n)

/*
THE DATABASE DOESN'T HAVE THE CAPACITY TO CONTROL OBLIGATORINESS BETWEEN TABLES, THE PROGRAM LANGUAGE IS WHAT DOES THAT.
HOWEVER, THE DATABASE HAS THE POWER TO CONTROL THE CARDINALITY OF AN INSERTION.
*/

/*
(x,y)
x -> means obligatoriness
y -> means cardinality

se x = 0 -> NOT OBRIGATORY
se x = 1 -> OBRIGATORY
se y = 1 -> JUST ONE
se y = n -> ONE OR MORE

CARDINALITY AND OBLIGATORINESS OPTIONS:
(0,n)
(0,1)
(1,n)
(1,1)

*1ª OBS: WHEN SOMETHING IS OBRIGATORY, THE MINIMUM TO HAVE IS ONE
*2ª OBS: THE CARDINALITY CONTROLS THE MAXIMUM ALLOWED.
*3ª OBS: THE READING OF THE CARDINALITY BETWEEN TABLES IS DONE FROM THE 2° NUMBER OF THE PAIR, OF EACH PAIR, CROSSING THEM TO DO THE READING.
EXAMPLE: MAIN TABLE(1,*1*) AND SECUNDARY TABLE(1,*n*) -> 
-> (1,*1*) e (1,*n*) BECOMES -> RELATIONSHIP BETWEEN THE TABLES (*1*,*n*)

*/

-- CREATING THE DATABASE TO RECEIVE THE MODELED DATA
CREATE DATABASE COMERCIO;
SHOW DATABASES;
USE COMERCIO;


-- TO DEFINE A COLUMN AS PRIMARY KEY WE MUST USE "PRIMARY KEY" AFTER THE DATA TYPE
-- WE DEFINE THE PRIMARY KEYS AS "AUTO_INCREMENT" TO AVOID CONFLICTS BY OTHER CONNECTIONS
-- UNIQUE DATA FROM REGISTER/PERSON MUST BE SPECIFIED AS "UNIQUE"

CREATE TABLE CLIENTE(
	IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	SEXO ENUM('F','M') NOT NULL, -- IT'S A DOMAIN WITH FIXED INFORMATION/OPTIONS, THE "ENUM" TYPE ONLY EXISTS IN MYSQL
	EMAIL VARCHAR(50) UNIQUE,
	CPF VARCHAR(15) UNIQUE
);

CREATE TABLE CLIENTE(
	IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	SEXO ENUM('F','M') NOT NULL,
	EMAIL VARCHAR(50) UNIQUE,
	CPF VARCHAR(15) UNIQUE
);

-- WHEN WE DEFINE A COLUMN AS PRIMARY KEY, THE COLUMN BECOMES OBRIGATORY.

DESC CLIENTE;

CREATE TABLE ENDERECO(
	IDENDERECO INT PRIMARY KEY AUTO_INCREMENT,
	RUA VARCHAR(50) NOT NULL,
	BAIRRO VARCHAR(50) NOT NULL,
	CIDADE VARCHAR(50) NOT NULL,
	ESTADO CHAR(2) NOT NULL,
	ID_CLIENTE INT UNIQUE,
	FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE) 
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
	TIPO ENUM('CEL', 'COM', 'RES') NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_CLIENTE INT,
	FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE)
);

-- ENDEREÇO É OBRIGATÓRIO, SOMENTE 1
-- TELEFONE É NÃO OBRIGATÓRIO, QUANTIDADE CADASTRADA É OPCIONAL

-- UNDERSTANDING FOREIGN KEY - FK

-- THE FOREIGN KEY IS THE PRIMARY KEY FROM A TABLE WHICH GOES TO OTHER TABLE TO DO REFERENCE BETWEEN REGISTERS OF BOTH TABLES.
-- THE CONCEPT OF STRONG/WEAK TABLE DEPENDS ON THE BUSINESS RULE. THERE ISN'T A CAKE RECIPE, IT'S NECESSARY TO KNOW THE BUSINESS RULE.

-- IN A RELATIONSHIP (1,1) THE FOREIGN KEY STAYS IN THE WEAK TABLE.
-- AS TABELAS CLIENTE E ENDERECO TEM A RELAÇÃO (1,1)
-- BASEADO NO NEGÓCIO, A TABELA MAIS FORTE É A CLIENTE
-- CONSEQUENTEMENTE A MAIS FRACA É A TABELA ENDERECO
-- A FK SERÁ CRIADA NAS TABELA ENDERECO, POIS É A MAIS FRACA


-- IN AN RELATIONSHIP (1,n) THE FOREIGN KEY STAYS IN THE N*/
-- THE VECTORIZING RULE JUSTIFIES THIS FOREIGN KEY RELATIONSHIP RULE


DROP TABLE CLIENTE; -- EXCLUDE THE TABLE "CLIENTE"

-- CONSTRAINT IS A RULE, AND MUST BE CREATED TO EFFECTIVE THE RELATIONSHIPS
-- THE FOREIGN KEY MUST HAVE THE SAME DATA TYPE OF THE REFERED PRIMARY KEY

-- INSERTING DATA IN THE CONFIGURED TABLES

USE COMERCIO;
SELECT * FROM CLIENTE;
DESC CLIENTE;

-- THIS NULL JUST INDICATES THAT THE MYSQL IS THE RESPONSIBLE FOR THE PRIMARY KEY, THE MYSQL REQUIRES THIS TO BE SPECIFIED

INSERT INTO CLIENTE VALUES (NULL, 'JOAO', 'M', 'JOAO@IG.COM','765667587887');
INSERT INTO CLIENTE VALUES (NULL, 'CARLOS', 'M', 'CARLOS@IG.COM','5464553466');
INSERT INTO CLIENTE VALUES (NULL, 'ANA', 'F', 'ANA@IG.COM','456545678');
INSERT INTO CLIENTE VALUES (NULL, 'CLARA', 'F', NULL,'5687766856');
INSERT INTO CLIENTE VALUES (NULL, 'JORGE', 'M', 'JORGE@IG.COM','8756547688');
INSERT INTO CLIENTE VALUES (NULL, 'CELIA', 'M', 'CELIA@IG.COM','5767876889');

/*
+-----------+--------+------+---------------+--------------+
| IDCLIENTE | NOME   | SEXO | EMAIL         | CPF          |
+-----------+--------+------+---------------+--------------+
|         1 | JOAO   | M    | JOAO@IG.COM   | 765667587887 |
|         2 | CARLOS | M    | CARLOS@IG.COM | 5464553466   |
|         3 | ANA    | F    | ANA@IG.COM    | 456545678    |
|         4 | CLARA  | F    | NULL          | 5687766856   |
|         5 | JORGE  | M    | JORGE@IG.COM  | 8756547688   |
|         6 | CELIA  | M    | CELIA@IG.COM  | 5767876889   |
+-----------+--------+------+---------------+--------------+
*/

INSERT INTO ENDERECO VALUES (NULL, 'RUA ANTONIO SA', 'CENTRO', 'B. HORIZONTE', 'MG', 4);
INSERT INTO ENDERECO VALUES (NULL, 'RUA CAPITAO HERMES', 'CENTRO', 'RIO DE JANEIRO', 'RJ', 1);
INSERT INTO ENDERECO VALUES (NULL, 'RUA PRES VARGAS', 'JARDINS', 'SAO PAULO', 'SP', 3);
INSERT INTO ENDERECO VALUES (NULL, 'RUA ALFANDEGA', 'ESTACIO', 'RIO DE JANEIRO', 'RJ', 2);
INSERT INTO ENDERECO VALUES (NULL, 'RUA DO OUVIDOR', 'FLAMENGO', 'RIO DE JANEIRO', 'RJ', 6);
INSERT INTO ENDERECO VALUES (NULL, 'RUA URUGUAIANA', 'CENTRO', 'VITORIA', 'ES', 5);

-- WHEN THERE IS "UNIQUE" BECAUSE THE (1,1) CARDINALITY, IT'S JUST ONE DATA BY PRIMARY KEY
-- WHEN THERE ISN'T "UNIQUE", IT INDICATES THE (1,n) CARDINALITY, THEREFORE THE PRIMARY KEY CAN REPEAT AS A TABLE FOREIGN KEY

INSERT INTO TELEFONE VALUES (NULL, 'CEL', '78458743', 5);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '34566544', 5);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '56845675', 1);
INSERT INTO TELEFONE VALUES (NULL, 'COM', '12346435', 2);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '87616346', 1);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '78453435', 3);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '78433335', 3);
INSERT INTO TELEFONE VALUES (NULL, 'COM', '78666666', 1);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '78433434', 5);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '78412121', 2);

-- DATABASE USES THE SET THEORY
-- "FROM" IS THE SOURCE
-- IN THE ORACLE A SOURCE IS ALWAYS REQUIRED
-- IN THE ORACLE EXISTS A TABLE JUST FOR FUNCTIONS

---------------------- \\ ----------------------

-- SELECTION, PROJECTION AND JOINT

-- PROJECTION -> IT'S EVERY INFORMATION YOU WANT TO SEE ON THE DISPLAY
-- IT CAN COME FROM A TABLE OR A PROGRAMMING
SELECT * FROM TELEFONE;
SELECT TIPO, NUMERO FROM TELEFONE;
SELECT NOW() AS DATA_ATUAL;
SELECT 2+2 AS SOMA;
SELECT 2+2 AS SOMA, NOME, NOW() FROM CLIENTE;

-- SELECTION ->  IT'S A FILTER THAT SELECTS A SUBSET OF A WHOLE TABLE'S REGISTERS SET
-- THE SELECTION CLAUSE IS "WHERE"
-- PEOPLE JOIN TABLES USING "WHERE", IT'S NOT THE IDEAL BUT IT WORKS.
SELECT NOME, SEXO, EMAIL
FROM CLIENTE -- SOURCE
WHERE SEXO ='F';

SELECT NUMERO
FROM TELEFONE
WHERE TIPO ='CEL';

-- JOINT -> JOIN
-- IT'S WHEN 2 OR MORE TABLE ARE JOINED
-- THE JOINT CLAUSE IS THE "JOIN"

SELECT NOME, EMAIL, IDCLIENTE 
FROM CLIENTE;

SELECT ID_CLIENTE, BAIRRO, CIDADE 
FROM ENDERECO;

/*
    -> FROM CLIENTE;
+--------+---------------+-----------+
| NOME   | EMAIL         | IDCLIENTE |
+--------+---------------+-----------+
| JOAO   | JOAO@IG.COM   |         1 |
| CARLOS | CARLOS@IG.COM |         2 |
| ANA    | ANA@IG.COM    |         3 |
| CLARA  | NULL          |         4 |
| JORGE  | JORGE@IG.COM  |         5 |
| CELIA  | CELIA@IG.COM  |         6 |
+--------+---------------+-----------+
*/

/*
+------------+----------+----------------+
| ID_CLIENTE | BAIRRO   | CIDADE         |
+------------+----------+----------------+
|          4 | CENTRO   | B. HORIZONTE   |
|          1 | CENTRO   | RIO DE JANEIRO |
|          3 | JARDINS  | SAO PAULO      |
|          2 | ESTACIO  | RIO DE JANEIRO |
|          6 | FLAMENGO | RIO DE JANEIRO |
|          5 | CENTRO   | VITORIA        |
+------------+----------+----------------+
*/

-- PROJECT NAME, GENDER, NEIGHBOURHOOD, CITY OF ALL CUSTOMERS
SELECT NOME, SEXO, BAIRRO, CIDADE -- PROJECTION
FROM CLIENTE, ENDERECO -- SOURCE
WHERE IDCLIENTE = ID_CLIENTE; -- JOINT

+--------+------+----------+----------------+
| NOME   | SEXO | BAIRRO   | CIDADE         |
+--------+------+----------+----------------+
| JOAO   | M    | CENTRO   | RIO DE JANEIRO |
| CARLOS | M    | ESTACIO  | RIO DE JANEIRO |
| ANA    | F    | JARDINS  | SAO PAULO      |
| CLARA  | F    | CENTRO   | B. HORIZONTE   |
| JORGE  | M    | CENTRO   | VITORIA        |
| CELIA  | M    | FLAMENGO | RIO DE JANEIRO |
+--------+------+----------+----------------+
-- IT WORKS BUT IT'S NO THE IDEAL, "WHERE" IS A SELECTION CLAUSE NOT OF JOINT.

SELECT NOME, SEXO, BAIRRO, CIDADE
FROM CLIENTE, ENDERECO
WHERE IDCLIENTE = ID_CLIENTE
AND SEXO ='F';

/*
+-------+------+---------+--------------+
| NOME  | SEXO | BAIRRO  | CIDADE       |
+-------+------+---------+--------------+
| ANA   | F    | JARDINS | SAO PAULO    |
| CLARA | F    | CENTRO  | B. HORIZONTE |
+-------+------+---------+--------------+
*/
-- USING TRUTH TABLE, LOGICAL OPERATOR

-- INNER JOIN DOES A CORRELATION BETWEEN IDS AND IT JUST RETURNS THE ONES WHICH HAVE A RELATION
SELECT NOME, SEXO, BAIRRO, CIDADE
FROM CLIENTE
INNER JOIN ENDERECO
ON IDCLIENTE = ID_CLIENTE;

/*
+--------+------+----------+----------------+
| NOME   | SEXO | BAIRRO   | CIDADE         |
+--------+------+----------+----------------+
| JOAO   | M    | CENTRO   | RIO DE JANEIRO |
| CARLOS | M    | ESTACIO  | RIO DE JANEIRO |
| ANA    | F    | JARDINS  | SAO PAULO      |
| CLARA  | F    | CENTRO   | B. HORIZONTE   |
| JORGE  | M    | CENTRO   | VITORIA        |
| CELIA  | M    | FLAMENGO | RIO DE JANEIRO |
+--------+------+----------+----------------+
*/

SELECT NOME, SEXO, BAIRRO, CIDADE -- PROJECTION
FROM CLIENTE -- SOURCE
	INNER JOIN ENDERECO -- JOINT
	ON IDCLIENTE = ID_CLIENTE
WHERE SEXO ='F'; -- SELECTION

/*
+-------+------+---------+--------------+
| NOME  | SEXO | BAIRRO  | CIDADE       |
+-------+------+---------+--------------+
| ANA   | F    | JARDINS | SAO PAULO    |
| CLARA | F    | CENTRO  | B. HORIZONTE |
+-------+------+---------+--------------+
*/

-- NOME, SEXO, EMAIL, TIPO, NUMERO
SELECT NOME, SEXO, EMAIL, TIPO, NUMERO
FROM CLIENTE
	INNER JOIN TELEFONE
	ON IDCLIENTE = ID_CLIENTE;
-- HOW HERE THE RELATION IS (1,n), THE NAMES MAY REPEAT BECAUSE A PERSON CAN HAVE MORE THAN ONE NUMBER.

---------------------- \\ ----------------------

-- DEEPENING IN JOIN, JOINING MORE THAN 2 TABLES

-- THERE WILL BE AN ERROR BECAUSE THE REFERENCES ARE INCORRECT
SELECT NOME, SEXO, BAIRRO, CIDADE, TIPO, NUMERO
FROM CLIENTE
	INNER JOIN ENDERECO
	ON IDCLIENTE = ID_CLIENTE
	INNER JOIN TELEFONE
	ON IDCLIENTE = ID_CLIENTE;

-- INSERTING THE ADRESS DATA, USING TABLE_NAME.TABLE_COLUMN_NAME
SELECT CLIENTE.NOME, CLIENTE.SEXO, ENDERECO.BAIRRO, ENDERECO.CIDADE, TELEFONE.TIPO, TELEFONE.NUMERO
FROM CLIENTE
	INNER JOIN ENDERECO
	ON CLIENTE.IDCLIENTE = ENDERECO.ID_CLIENTE
	INNER JOIN TELEFONE
	ON CLIENTE.IDCLIENTE = TELEFONE.ID_CLIENTE;

-- USE OF ALIAS - INCREASES THE DATABASE PERFOMANCE
	SELECT C.NOME, C.SEXO, E.BAIRRO, E.CIDADE, T.TIPO, T.NUMERO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE;

---------------------- \\ ----------------------

-- SQL IS 4º GEN PROGRAMMING LANGUAGE, WHICH IS DIVIDED BY CATEGORIES.

-- DML -> DATA MANIPULATION LANGUAGE
INSERT INTO CLIENTE VALUES(NULL, 'PAULA', 'M', NULL, '77437493');
INSERT INTO ENDERECO VALUES(NULL, 'RUA JOAQUIM SILVA', 'ALVORADA', 'NITEROI', 'RJ', 7);

SELECT *
FROM CLIENTE
WHERE SEXO ='M';

SELECT IDCLIENTE, NOME, SEXO
FROM CLIENTE
WHERE SEXO ='M' AND NOME = 'PAULA';

SELECT IDCLIENTE, NOME, SEXO
WHERE IDCLIENTE = 7;

UPDATE CLIENTE
SET SEXO ='F'
WHERE IDCLIENTE = 7;

INSERT INTO CLIENTE VALUES(NULL, 'XXX', 'M', NULL, 'XXX');

SELECT * FROM CLIENTE
WHERE IDCLIENTE = 8;

DELETE FROM CLIENTE
WHERE IDCLIENTE = 8;

-- DDL -> DATA DEFINITION LANGUAGE
CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME_PRODUTO VARCHAR(30) NOT NULL,
	PRECO INT,
	FRETE FLOAT(10,2) NOT NULL
);

-- ALTER -- COMMAND USED ALONG OTHER TO CHANGE SOMETHING IN A TABLE

-- CHANGE -- USED TO CHANCE THE COLUMNS NAME
-- STRUCTURE -> CHANGE OLD_COLUMN_NAME NEW_COLUMN_NAME NEW_COLUMN_TYPE;
ALTER TABLE PRODUTO
CHANGE PRECO VALOR_UNITARIO INT NOT NULL;

DESC PRODUTO;

ALTER TABLE PRODUTO
CHANGE VALOR_UNITARIO VALOR_UNITARIO INT;

DESC PRODUTO;

-- MODIFY - USED TO CHANGE THE COLUMN TYPE
-- MODIFY COLUMN_NAME NEW_COLUMN_TYPE;
ALTER TABLE PRODUTO
MODIFY VALOR_UNITARIO VARCHAR(50) NOT NULL;

-- ADDING A COLUMN
ALTER TABLE PRODUTO
ADD PESO FLOAT(10,2) NOT NULL;

ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL;

-- ADDING A COLUMN IN AN SPECIFIC ORDER
-- AFTER
ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL 
AFTER VALOR_UNITARIO;

-- FIRST
ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL 
FIRST;

DESC PRODUTO;

-- ERASING A TABLE'S COLUMN
ALTER TABLE PRODUTO
DROP COLUMN PESO;

-- DCL -> DATA CONTROL LANGUAGE
-- TCL -> TRANSACTION CONTROL LANGUAGE

---------------------- \\ ----------------------

-- ERASING A DATABASE PERMANENTLY

DROP DATABASE ANY_DATABASE_NAME;

---------------------- \\ ----------------------

-- 1. RELATORIO GERAL DE TODOS OS CLIENTES (TELEFONE E ENDEREÇO TAMBÉM)
DESC CLIENTE;
DESC ENDERECO;
DESC TELEFONE;


-- JEITO DO ANDRÉ
SELECT *
FROM CLIENTE
	INNER JOIN ENDERECO
	ON CLIENTE.IDCLIENTE = ENDERECO.ID_CLIENTE
	INNER JOIN TELEFONE
	ON CLIENTE.IDCLIENTE = TELEFONE.ID_CLIENTE;

-- JEITO DO MAFRA
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, 
       E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO,
	   T.TIPO, T.NUMERO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE;

-- 2. RELATORIO GERAL DE TODOS OS CLIENTES (TELEFONE E ENDERECO)
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, 
       E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO,
	   T.TIPO, T.NUMERO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
WHERE SEXO ='M';

SELECT * FROM CLIENTE
WHERE IDCLIENTE = 11
OR IDCLIENTE = 12
OR IDCLIENTE = 16
OR IDCLIENTE = 17;

-- 3. RELATORIO DE MULHERES
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, 
       E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO,
	   T.TIPO, T.NUMERO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
WHERE SEXO ='F';

UPDATE CLIENTE
SET SEXO ='M'
WHERE IDCLIENTE = 13;

-- 4. QUANTIDADE DE HOMENS E MULHERES
SELECT SEXO, COUNT(*) AS QUANTIDADE
FROM CLIENTE
GROUP BY SEXO;

-- 5. IDS E EMAILS DAS MULHERES QUE MOREM NO CENTRO DO RIO DE JANEIRO E QUE NAO TENHAM CELULAR
SELECT C.IDCLIENTE, C.SEXO, C.EMAIL, E. BAIRRO, E.CIDADE, T.TIPO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
WHERE SEXO ='F'
AND BAIRRO ='CENTRO' 
AND CIDADE ='RJ';

SELECT C.IDCLIENTE, C.SEXO, C.EMAIL, E. BAIRRO, E.CIDADE, T.TIPO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
WHERE SEXO ='F'
AND BAIRRO ='CENTRO' 
AND CIDADE ='RJ',
AND (TIPO = 'RES' OR TIPO = 'COM');
AND TIPO != 'CEL';

/*
-- 6. PARA UMA CAMPANHA DE MARKETING, O SETOR SOLICITOU UM RELATÓRIO COM O
NOME, EMAIL E TELEFONE CELULAR DOS CLIENTES QUE MORAM NO ESTADO DO RIO DE
JANEIRO. VOCÊ TERÁ QUE PASSAR A QUERY PARA GERAR O RELATÓRIO PARA O
PROGRAMADOR
*/
SELECT C.NOME, C.EMAIL, T.NUMERO AS CELULAR, E.ESTADO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
WHERE ESTADO ='RJ'
AND TIPO ='CEL';


/*
-- 7. PARA UMA CAMPANHA DE PRODUTOS DE BELEZA, O COMERCIAL SOLICITOU UM
RELATÓRIO COM O NOME, EMAIL E TELEFONE CELULAR DAS MULHERES QUE MORAM
NO ESTADO DE SÃO PAULO. VOCÊ TERÁ QUE PASSAR A QUERY PARA GERAR O
RELATORIO PARA O PROGRAMADOR
*/
SELECT C.NOME, C.EMAIL, T.NUMERO AS CELULAR, E.ESTADO -- PROJECAO
FROM CLIENTE C -- FIRST SOURCE, MUST BE THE TABLE WITH THE MOST CONNECTIONS
	INNER JOIN ENDERECO E -- JOINT
	ON C.IDCLIENTE = E.ID_CLIENTE -- JOINT CONDITION
	INNER JOIN TELEFONE T -- JOINT
	ON C.IDCLIENTE = T.ID_CLIENTE -- JOINT CONDITION
WHERE SEXO = 'F'  -- SELECTION 
AND ESTADO ='SP'  -- SELECTION
AND TIPO = 'CEL'; -- SELECTION

---------------------- \\ ----------------------

-- FILTRO IN - CHOOSES SPECIFIC VALUES INSTEAD OF USING SEVERAL ORS
SELECT * FROM CLIENTE
WHERE IDCLIENTE IN (12, 13, 18, 19); 

UPDATE CLIENTE
SET SEXO = 'F'
WHERE IDCLIENTE IN (12, 13, 18, 19); 

---------------------- \\ ----------------------

-- FUNCTION
-- IT'S A BLOCK OF A PROGRAMMING SCRIPT THAT EXECUTES SOMETHING
-- THERE ARE FUNCTIONS WITH OR WITHOUT PARAMETERS;

-- FUNÇÃO IFNULL()
-- IFNULL(COLUMNNAME, STRING)
SELECT C.NOME, 
IFNULL(C.EMAIL, 'NÃO TEM EMAIL'), 
E.ESTADO, 
T.NUMERO
FROM CLIENTE C
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE;

---------------------- \\ ----------------------

-- VIEWS
-- IT'S A VISION, THE VIEW WILL POINT TO A QUERY
-- THE PURPOSE OF THE VIEW IS TO FACILITATE THE QUERY
-- THE VIEWS ARE DISPLAYED IN THE "SHOW TABLES" COMMAND.
-- THE VIEW DOESN'T DUPLICATE THE DATABASE DATA. IT IS BASICALLY A VIRTUAL TABLE.

CREATE VIEW RELATORIO AS
SELECT C.NOME,
	   C.SEXO,
	   C.EMAIL,
	   T.TIPO,
	   T.NUMERO,
	   E.BAIRRO,
	   E.CIDADE,
	   E.ESTADO
FROM CLIENTE C
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE;

SELECT * FROM RELATORIO;

-- ERASING A VIEW
DROP VIEW RELATORIO;

-- IDENTIFYING A VIEW
CREATE VIEW V_RELATORIO AS
SELECT C.NOME,
	   C.SEXO,
	   IFNULL(C.EMAIL, 'CLIENTE SEM EMAIL') AS EMAIL,
	   T.TIPO,
	   T.NUMERO,
	   E.BAIRRO,
	   E.CIDADE,
	   E.ESTADO
FROM CLIENTE C
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE;

-- PROJECTING COLUMNS FROM A VIEW
SELECT NOME, NUMERO, ESTADO FROM V_RELATORIO;

---------------------- \\ ----------------------

-- DML COMMANDS IN VIEW
-- DELETE, INSERT AND UPDATE

INSERT INTO V_RELATORIO VALUES(
	'ANDREIA',
	'F',
	'ANDREIA@UOL.COM.BR',
	'CEL',
	'789456324',
	'CENTRO',
	'VITORIA',
	'ES'
);


-- VIEWS FROM TABLES WITH JOINTS
-- DELETE NOT ALLOWED;
-- INSERT NOT ALLOWED;
-- UPDATE ALLOWED;

-- VIEWS FROM TABLES WITHOUT JOINTS
-- DELETE ALLOWED;
-- INSERT ALLOWED;
-- UPDATE ALLOWED;
-- **BE CAREFUL WITH THE TABLE'S RESTRICTIONS

-- **IN BOTH CASES, THE ALLOWED COMMANDS JUST WORK FOR THE DEFINED COLUMNS FOR THE VIEW.

---------------------- \\ ----------------------

-- ORDER BY COMMAND

-- THE ONLY WAY TO SORT A TABLE IS USING THE ORDER BY COMMAND, WITHOUT HIM THE RESULT IS RANDOM.

CREATE TABLE ALUNOS (
	NUMERO INT,
	NOME VARCHAR(30)
);

INSERT INTO ALUNOS VALUES (1,'JOAO');
INSERT INTO ALUNOS VALUES (1,'MARIA');
INSERT INTO ALUNOS VALUES (2,'ZOE');
INSERT INTO ALUNOS VALUES (2,'ANDRE');
INSERT INTO ALUNOS VALUES (3,'CLARA');
INSERT INTO ALUNOS VALUES (1,'CLARA');
INSERT INTO ALUNOS VALUES (4,'MAFRA');
INSERT INTO ALUNOS VALUES (5,'JANAINA');
INSERT INTO ALUNOS VALUES (1,'JANAINA');
INSERT INTO ALUNOS VALUES (3,'MARCELO');
INSERT INTO ALUNOS VALUES (4,'GIOVANI');
INSERT INTO ALUNOS VALUES (5,'ANTONIO');
INSERT INTO ALUNOS VALUES (6,'ANA');
INSERT INTO ALUNOS VALUES (6,'VIVIANE');

SELECT *
FROM ALUNOS
ORDER BY NUMERO;

SELECT *
FROM ALUNOS
ORDER BY 1;

-- EX: "ORDER BY 1" = ORDER BY THE FIRST COLUMN TYPED IN THE PROJECTION

-- ORDER BY WITH SEVERAL COLUMNS
SELECT *
FROM ALUNOS
ORDER BY NUMERO, ALUNO;

SELECT *
FROM ALUNOS
ORDER BY 1,2;

-- MIXING ORDER BY WITH PROJECTION
SELECT NOME
FROM ALUNOS
ORDER BY 1,2;
-- *YOU CAN'T ORDER BY USING NUMBERS IF THE COLUMN ISN'T IN THE PROJECTION

SELECT NOME
FROM ALUNOS
ORDER BY NUMERO, NOME;
-- *NOW IT'LL WORK BECAUSE THE COLUMN NAME WAS SPECIFIED

-- ORDER BY DESC/ASC
-- THE "ORDER BY" COMMAND WITHOUT "DESC/ASC" WILL ASSUME "ASC" AS THE STANDARD
-- THE "ORDER BY" COMMAND AS "DESC" MUST BE SPECIFIED IF IT IS THE INTENTION

SELECT *
FROM ALUNOS
ORDER BY 1,2;

SELECT *
FROM ALUNOS
ORDER BY 1 ASC;

SELECT *
FROM ALUNOS
ORDER BY 1 DESC;

SELECT *
FROM ALUNOS
ORDER BY 1, 2 DESC;

SELECT *
FROM ALUNOS
ORDER BY 1 DESC, 2 DESC;

-- "ORDER BY" WITH JOINTS/VIEWS

SELECT C.NOME,
	   C.SEXO,
	   IFNULL(C.EMAIL, 'CLIENTE SEM EMAIL') AS EMAIL,
	   T.TIPO,
	   T.NUMERO,
	   E.BAIRRO,
	   E.CIDADE,
	   E.ESTADO
FROM CLIENTE C
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE
ORDER BY 1;

SELECT * 
FROM V_RELATORIO
ORDER BY 1;

---------------------- \\ ----------------------

-- DELIMITER

-- THE STANDARD DELIMITER OF SQL IS ";"
-- EVERYTIME THAT THE DATABASE IS RESTARTED, THE DELIMITER RETURNS TO ITS STANDARD
-- THE DATABASE AWAITS THE DELIMITER TO RUN THE INSTRUCTIONS TYPED PREVIOUSLY THE DELIMITER
-- TO PROGRAM INSIDE THE DATABASE CHANGING THE DELIMITER IS NECESSARY.
-- 

STATUS        -- VER QUAL O DELIMITADOR ATUAL
DELIMITER $   -- CHANGING THE DELIMITER TO $

---------------------- \\ ----------------------

-- PROCEDURES
-- IT'S A KNOWN PROGRAMMING BLOCK, NAMED BLOCK.

-- STORAGE PROCEDURES

SELECT 'MAFRA'; -- THIS IS AN ANONYMOUS BLOCK, DIFFERENT THAN A PROCEDURE


CREATE PROCEDURE PROCEDURE_NAME()
BEGIN
ANY PROGRAMATION;
END
$

CREATE PROCEDURE NOME_EMPRESA()
BEGIN
	SELECT 'UNIVERSIDADE DOS DADOS' AS EMPRESA;
END
$

DELIMITER ;

-- CALLING THE PROCEDURE

CALL PROCEDURE_NOME();

-- PROCEDURE WITH PARAMETERS

DELIMITER $

CREATE PROCEDURE CONTA()
BEGIN
	SELECT 10 + 10 AS CONTA;
END
$

CALL CONTA();

DROP PROCEDURE CONTA;

CREATE PROCEDURE CONTA(NUMERO1 INT, NUMERO2 INT)
BEGIN
	SELECT NUMERO1 + NUMERO2 AS CONTA;
END
$

---------------------- \\ ----------------------

-- PROCEDURES IN THE REAL WORLD

-- THERE ARE PROS AND CONS ABOUT ALLOCATING BUSINESS RULES IN THE LAYERS "CONTROLLER" AND "MODEL" 
-- IT DEPENDS ON THE CASE, THE BUSINESS RULE AND THE PROGRAMMER.
-- IT'S NOT A CAKE RECIPE

CREATE DATABASE PROJETO;
USE PROJETO;

CREATE TABLE CURSOS (
	IDCURSO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	HORAS INT(3) NOT NULL,
	VALOR FLOAT(10,2) NOT NULL
);

INSERT INTO CURSOS VALUES(NULL, 'JAVA', 30, 500.00);
INSERT INTO CURSOS VALUES(NULL, 'FUNDAMENTOS DE BANCOS DE DADOS', 40, 700.00);

-- WE'LL BYPASS THE CONTROLLER LAYER OF THE MVC AND DO SOME BUSINESS RULES IN THE MODEL LAYER

DELIMITER #

CREATE PROCEDURE CAD_CURSO(P_NOME VARCHAR(30),
						   P_HORAS INT(3),
						   P_VALOR FLOAT(10,2))
BEGIN
	INSERT INTO CURSOS VALUES(NULL, P_NOME, P_HORAS, P_VALOR);
END
#

DELIMITER ;

CALL CAD_CURSO('BI SQL SERVER', 35,3000.00);
CALL CAD_CURSO('POWER BI', 20, 1000.00);
CALL CAD_CURSO('TABLEAU', 30, 1200.00);
CALL CAD_CURSO('PHP', 40, 1872.00);
CALL CAD_CURSO('C#', 50, 653.00);
CALL CAD_CURSO('RUST', 12, 2421.00);
CALL CAD_CURSO('RUBY ON RAILS', 23, 4000.00);
CALL CAD_CURSO('SQL SERVER', 34, 700.00);
CALL CAD_CURSO('POSTGRE SQL', 11, 150.00);
CALL CAD_CURSO('ORACLE', 40, 500.00);
CALL CAD_CURSO('PASCAL', 20, 200.00);

DELIMITER #

CREATE PROCEDURE CONSULTAR_CURSO()
BEGIN
	SELECT NOME, HORAS, VALOR
	FROM CURSOS
	ORDER BY 1;
END #

CALL CONSULTAR_CURSO();

---------------------- \\ ----------------------

-- FUNCTIONS COUNT, MAX, MIN, AVG AND GROUP BY

CREATE TABLE VENDEDORES(
	IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR (30),
	SEXO CHAR(1),
	JANEIRO FLOAT(10,2),
	FEVEREIRO FLOAT(10,2),
	MARCO FLOAT(10,2)
);

INSERT INTO VENDEDORES VALUES(NULL,'CARLOS', 'M', 12345.87, 25863.98, 74125.25);
INSERT INTO VENDEDORES VALUES(NULL,'MARIA', 'F', 582.87, 7913.98, 89.25);
INSERT INTO VENDEDORES VALUES(NULL,'ANTONIO', 'M', 985.87, 3197.98, 87.25);
INSERT INTO VENDEDORES VALUES(NULL,'CLARA', 'F', 147.87, 7193.98, 19.25);
INSERT INTO VENDEDORES VALUES(NULL,'ANDERSON', 'M', 357.87, 9371.98, 55.25);
INSERT INTO VENDEDORES VALUES(NULL,'IVONE', 'F', 159.87, 3719.98, 66.25);
INSERT INTO VENDEDORES VALUES(NULL,'JOAO', 'M', 813.87, 9137.98, 789.25);
INSERT INTO VENDEDORES VALUES(NULL,'CELIA', 'F', 279.87, 7391.98, 321.25);

-- MAX - DISPLAYS THE MAXIMUM VALUE FROM ALL THE VALUES
SELECT MAX(FEVEREIRO) AS 'MAIOR_FEV'
FROM VENDEDORES;

-- MIN - DISPLAYS THE MINIMUM VALUE FROM ALL THE VALUES
SELECT MIN(FEVEREIRO) AS 'MINIMO_FEV'
FROM VENDEDORES;

-- AVG - DISPLAYS THE CALCULATED AVERAGE VALUE AMIDST ALL THE VALUES
-- AUTOMATICALLY CALCULATES THE ARITMETICAL AVERAGE OF A COLUMN'S VALUES

SELECT AVG(FEVEREIRO) AS 'MEDIA_FEV'
FROM VENDEDORES;

-- ALL TOGETHER
SELECT MAX(JANEIRO) AS MAX_JAN,
	   MIN(JANEIRO) AS MIN_JAN,
	   AVG(JANEIRO) AS MED_JAN
FROM VENDEDORES;

-- TRUNCATE
-- LIMITS THE DECIMAL PLACES BUT DOES NOT ROUNDS THE NUMBER
TRUNCATE(ANY_NUMBER, MAX_DECIMAL_PLACES);

SELECT TRUNCATE(200.859, 2) AS EXAMPLE;

SELECT TRUNCATE(MAX(JANEIRO),2) AS MAX_JAN,
	   TRUNCATE(MIN(JANEIRO),2) AS MIN_JAN,
	   TRUNCATE(AVG(JANEIRO),2) AS MED_JAN
FROM VENDEDORES;

-- SUM
-- SUM ALL VALUES FROM A COLUMN
SELECT SUM(JANEIRO) AS TOTAL_JAN
FROM VENDEDORES;

-- SALES BY GENDER
SELECT SUM(MARCO) AS TOTAL_MARCO
FROM VENDEDORES
GROUP BY SEXO;

---------------------- \\ ----------------------

-- SUBQUERIES

-- WHICH SALESMAN SOLD LESS IN MARCH AND THEIR NAME ?
SELECT MIN(MARCO) FROM VENDEDORES; -- DÁ CERTO!
SELECT NOME, MIN(MARCO) FROM VENDEDORES; -- !!! ERRADO !!!
-- \/ RIGHT WAY! \/
SELECT NOME, MARCO FROM VENDEDORES
WHERE MARCO = (SELECT MIN(MARCO) FROM VENDEDORES);
-- >> (SELECT MIN(MARCO) FROM VENDEDORES) << INNER QUERY THAT WILL BE SOLVED FIRST

-- WHICH SALESMAN SOLD MORE IN MARCH AND THEIR NAME ?
SELECT NOME, MARCO FROM VENDEDORES
WHERE MARCO = (SELECT MAX(MARCO) FROM VENDEDORES);

-- WHO SOLD MORE THAN THE FEBUARY AVERAGE VALUE ?
SELECT NOME, MARCO FROM VENDEDORES
WHERE MARCO > (SELECT AVG(MARCO) FROM VENDEDORES);

-- WHO SOLD LESS THAN THE FEBUARY AVERAGE VALUE ?
SELECT NOME, MARCO FROM VENDEDORES
WHERE MARCO < (SELECT AVG(MARCO) FROM VENDEDORES);

-- *CONDITION COLUMNS MUST HAVE THE SAME QUANTITY AS THE COLUMNS IN THE INNER QUERY

---------------------- \\ ----------------------

-- LINE ARITMETICAL OPERATIONS

SELECT NOME,
       JANEIRO,
	   FEVEREIRO,
	   MARCO,
	   (JANEIRO + FEVEREIRO + MARCO) AS 'TOTAL',
	   TRUNCATE(((JANEIRO+FEVEREIRO+MARCO)/3),2) AS 'MÉDIA',
FROM VENDEDORES;

-- APPLYING %
SELECT NOME,
       JANEIRO,
	   FEVEREIRO,
	   MARCO,
	   (JANEIRO + FEVEREIRO + MARCO) AS 'TOTAL',
	   (JANEIRO + FEVEREIRO + MARCO)*0.25 AS 'DESCONTO',
	   TRUNCATE(((JANEIRO+FEVEREIRO+MARCO)/3),2) AS 'MÉDIA'
FROM VENDEDORES;

---------------------- \\ ----------------------

-- ALTERING A TABLE

CREATE TABLE TABELA(
	COLUNA1 VARCHAR(30),
	COLUNA2 VARCHAR(30),
	COLUNA3 VARCHAR(30)
);

-- DEFINING AN EXISTING COLUMN AS PRIMARY KEY
-- *AUTO_INCREMENT IS UNAVAILABLE IN THIS WAY TO DEFINE A PRIMARY KEY
ALTER TABLE TABELA
ADD PRIMARY KEY (COLUNA1);

-- ADDING A COLUMN WITHOUT POSITION (LAST POSITION)
ALTER TABLE TABELA
ADD COLUNA varchar(30);

-- ADDING A COLUMN WITH POSITION
ALTER TABLE TABELA
ADD COLUMN COLUNA4 VARCHAR(30) NOT NULL UNIQUE
AFTER COLUNA 3;

-- MODIFYING A FIELD TYPE
ALTER TABLE TABELA
MODIFY COLUNA2 DATE NOT NULL;

-- RENAMING A TABLE
ALTER TABLE TABELA
RENAME PESSOA;

-- ADDING A FOREIGN KEY
ALTER TABLE TIME
ADD FOREIGN KEY(ID_PESSOA)
REFERENCES PESSOA (COLUNA1);

-- VERIFYING KEYS - TABLE'S DESCRIPTION
SHOW CREATE TABLE TABELA;

-- CHARSET
-- CHARACTERS SET
-- THE TABLE INHERITS THE CHARSET OF THE DATABASE
-- LATIM1 - SET OF CHARACTERS LATIN AMERICAN
-- MAN - SET OF CHARACTERS OCIDENTAL
-- UTF8 - AN ATTEMPT TO UNIFY ALL THE CHARSETS

---------------------- \\ ----------------------

-- ORGANIZING KEYS

-- KEY IS A CONSTRAINT, A RULE
-- THE KEY IS A REFERENCIAL INTEGRITY RULE
-- THE PRIMARY KEY WILL ENSURE THAT THE REGISTER IS UNIQUE
-- THE FOREIGN KEY WILL ENSURE THAT WON'T HAVE ANY REGISTER IN A TABLE WITHOUT A REFERENCE IN OTHER TABLE

CREATE TABLE JOGADOR(
	IDJOGADOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30)
);

CREATE TABLE TIMES(
	IDTIME INT PRIMARY KEY AUTO_INCREMENT,
	NOMETIME VARCHAR(30),
	ID_JOGADOR INT,
	FOREIGN KEY(ID_JOGADOR) REFERENCES JOGADOR(IDJOGADOR)
);

INSERT INTO JOGADOR VALUES (NULL, 'GUERRERO');
INSERT INTO TIMES VALUES(NULL, 'FLAMENGO',1);

-- "CONSTRAINT 'times-ibfk_1' FOREIGN KEY ('ID_JOGADOR') REFERENCES 'JOGADOR' ('IDJOGADOR')

/* 
WHEN WE CREATE A CONSTRAINT INSIDE A TABLE'S CREATE,
THE DATABASE ITSELF NAMES RANDOMLY THE CONSTRAINT.
IT ISN'T A GOOD PRACTICE.

1º WE CREATE THE TABLE
2º WE CREATE THE CONSTRAINT OUTSIDE THE TABLE.
*/

---------------------- \\ ----------------------

-- NAMED CONSTRAINTS AND DATA DICTIONARY
-- CONSTRAINTS ACTIONS
-- MYSQL DOESN'T NAME THE PRIMARY KEY, BUT WE MUST NAME IT OUTSIDE THE CREATE COMMAND
-- 1º WE CREATE ALL THE TABLES
-- 2º THAN WE CREATE ALL THE CONSTRAINTS OUTSIDE THE TABLES
-- THIS PRACTICE ENSURE ORGANIZATION

SHOW TABLES;
DROP TABLE ENDERECO;
DROP TABLE TELEFONE;
DROP TABLE CLIENTE;

CREATE TABLE CLIENTE(
	IDCLIENTE INT,
    NOME VARCHAR(30) NOT NULL
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_CLIENTE INT UNIQUE
);

ALTER TABLE CLIENTE
ADD CONSTRAINT PK_CLIENTE
PRIMARY KEY(IDCLIENTE);

ALTER TABLE TELEFONE
ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) 
REFERENCES CLIENTE(IDCLIENTE);

SHOW CREATE TABLE TELEFONE;

-- DATA DICTIONARY
-- NOT ALL DATABASES HAVE PROMPT FUNCTIONS AS "SHOW TABLES"
-- THE DATA DICIONARY STORAGES THE METADATA
-- METADATA IS THE DATA ABOUT THE DATA.

SHOW DATABASES;

-- INFORMATION_SCHEMA - MYSQL - PERFORMANCE_SCHEMA BELONGS TO THE DATA DICTIONARY

USE INFORMATION_SCHEMA;
STATUS; --* UPTIME DISPLAYS HOW LONG THE PC/SERVER/MYSQLSERVICE HAS BEEN ON
DESC TABLE_CONSTRAINTS;
SELECT CONSTRAINT_SCHEMA AS 'BANCO',
       TABLE_NAME AS 'TABELA',
	   CONSTRAINT_TYPE AS 'TIPO',
	   CONSTRAINT_NAME AS 'NOME DA CONSTRAINT'
FROM TABLE_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'PROJETO';

ALTER TABLE TELEFONE
DROP FOREIGN KEY FK_CLIENTE_TELEFONE;

-- MASS INSERTTON
-- DROP FOREIGN KEY -> INSERT DATA -> CREATE REFERENCIAL INTEGRITY

---------------------- \\ ----------------------

-- CARDINALITY REVISION

-- WHERE STAYS THE FOREIGN KEY ?
-- FIRST WE MUST REMEMBER THAT THE BUSINESS RULES DEFINES THE CARDINALITY, NOT THE PROGRAMMER.
-- (1,1) - FOREIGN KEYS STAYS IN THE WEAKEST TABLE
-- (1,n) - FOREIGN KEYS STAYS IN THE TABLE WHICH HAS THE CARDINALITY "N"
-- (n,n) - WE USE AN ASSOCIATIVE TABLE

-- EXAMPLES OF RELATION BETWEEN CLIENT AND ADDRESS TABLES
-- (1,1) - 1 CLIENT HAS 1 ADDRESS -- FK IN ADDRESS TABLE
-- (1,n) - 1 CLIENT HAS SEVERAL ADDRESSES -- FK IN ADDRESS TABLE

---------------------- \\ ----------------------

-- EXERCICIO - O SISTEMA DO SEU JOSÉ - A OFICINA
-- LEARNING (n,n) RELATION
-- WE WILL NEED AN ASSOCIATIVE TABLE BETWEEN THE TWO n's
-- 1 CUSTOMER 1 CAR

CREATE DATABASE OFICINA;
USE OFICINA;

CREATE TABLE CLIENTE(
	IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	SEXO ENUM('M','F') NOT NULL,
	ID_CARRO INT NOT NULL UNIQUE
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
	TIPO ENUM('CEL', 'COM', 'RES') NOT NULL,
	NUMERO VARCHAR(18) NOT NULL,
	ID_CLIENTE INT NOT NULL
);

CREATE TABLE MARCA(
	IDMARCA INT PRIMARY KEY AUTO_INCREMENT,
	MARCA VARCHAR(30) NOT NULL UNIQUE
);

CREATE TABLE CARRO(
	IDCARRO INT PRIMARY KEY AUTO_INCREMENT,
	PLACA VARCHAR(30) NOT NULL UNIQUE,
	MODELO VARCHAR(30) NOT NULL,
	ID_MARCA INT NOT NULL
);

CREATE TABLE COR(
	IDCOR INT PRIMARY KEY AUTO_INCREMENT,
	COR VARCHAR(10) NOT NULL UNIQUE
);

CREATE TABLE CARRO_COR(
	ID_CARRO INT,
	ID_COR INT,
	PRIMARY KEY(ID_CARRO, ID_COR)
);
-- THE ASSOCIATION CAN'T REPEAT

---------------------- \\ ----------------------

-- CONSTRAINTS

-- FK CONSTRAINT PATTERN
/*
ALTER TABLE FKDESTINATIONTABLE
ADD CONSTRAINT FK_FKDESTINATIONTABLE_PKSOURCETABLE
FOREIGN KEY(DESTINATIONTABLE_ID) 
REFERENCES SOURCETABLE(SOURCETABLE_ID);
*/

ALTER TABLE CLIENTE
ADD CONSTRAINT FK_CLIENTE_CARRO
FOREIGN KEY(ID_CARRO) 
REFERENCES CARRO(IDCARRO);

ALTER TABLE TELEFONE
ADD CONSTRAINT FK_TELEFONE_CLIENTE
FOREIGN KEY(ID_CLIENTE)
REFERENCES CLIENTE(IDCLIENTE);

ALTER TABLE CARRO
ADD CONSTRAINT FK_CARRO_MARCA
FOREIGN KEY(ID_MARCA)
REFERENCES MARCA(IDMARCA);

ALTER TABLE CARRO_COR
ADD CONSTRAINT FK_COR
FOREIGN KEY(ID_COR)
REFERENCES COR(IDCOR);

ALTER TABLE CARRO_COR
ADD CONSTRAINT FK_CARRO
FOREIGN KEY(ID_CARRO)
REFERENCES CARRO(IDCARRO);

-- A PRIMARY KEY CAN BE A FOREIGN KEY SIMULTANEOUSLY
-- ASSOCIATIVE TABLES CAN RECEIVE ANOTHER TYPES OF DATA

USE INFORMATION_SCHEMA;
SHOW TABLES;
DESC TABLE_CONSTRAINTS;

SELECT * FROM TABLE_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'OFICINA';

SELECT CONSTRAINT_SCHEMA AS 'BANCO',
       TABLE_NAME AS 'TABELA',
	   CONSTRAINT_TYPE AS 'TIPO',
	   CONSTRAINT_NAME AS 'NOME DA CONSTRAINT'
FROM TABLE_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'OFICINA';

-- PREENCHER EXERCICIO COM NO MINIMO 10 CLIENTES
-- CARRO > COR > MARCA > CLIENTE > TELEFONE

INSERT INTO CARRO VALUES (NULL, 'AKU-1234', 'GOL', 1);
INSERT INTO CARRO VALUES (NULL, 'BLV-2143', 'FOX', 1);
INSERT INTO CARRO VALUES (NULL, 'CMW-3152', 'CRUZE', 2);
INSERT INTO CARRO VALUES (NULL, 'DNX-4261', 'ONIX', 2);
INSERT INTO CARRO VALUES (NULL, 'EOY-5371', 'STRADA', 3);
INSERT INTO CARRO VALUES (NULL, 'FPZ-6482', 'ARGO', 3);
INSERT INTO CARRO VALUES (NULL, 'GQA-7593', 'XC60', 4);
INSERT INTO CARRO VALUES (NULL, 'HRB-8694', 'VC80', 4);
INSERT INTO CARRO VALUES (NULL, 'ISC-9785', 'HB20', 5);
INSERT INTO CARRO VALUES (NULL, 'JTD-9876', 'ELANTRA', 5);

INSERT INTO MARCA VALUES (NULL,'VOLKSWAGEN');
INSERT INTO MARCA VALUES (NULL,'CHEVROLET');
INSERT INTO MARCA VALUES (NULL,'FIAT');
INSERT INTO MARCA VALUES (NULL,'VOLVO');
INSERT INTO MARCA VALUES (NULL,'HYUNDAI');
INSERT INTO MARCA VALUES (NULL,'NISSAN');
INSERT INTO MARCA VALUES (NULL,'TOYOTA');
INSERT INTO MARCA VALUES (NULL,'FORD');
INSERT INTO MARCA VALUES (NULL,'RENAULT');
INSERT INTO MARCA VALUES (NULL,'MERCEDES');

INSERT INTO COR VALUES (NULL, 'BRANCO');
INSERT INTO COR VALUES (NULL, 'PRETO');
INSERT INTO COR VALUES (NULL, 'VERMELHO');
INSERT INTO COR VALUES (NULL, 'VERDE');
INSERT INTO COR VALUES (NULL, 'AZUL');
INSERT INTO COR VALUES (NULL, 'AMARELO');
INSERT INTO COR VALUES (NULL, 'MARROM');
INSERT INTO COR VALUES (NULL, 'CINZA');
INSERT INTO COR VALUES (NULL, 'ROSA');
INSERT INTO COR VALUES (NULL, 'ROXO');

INSERT INTO CLIENTE VALUES (NULL, 'JOAO', 'M', 1);
INSERT INTO CLIENTE VALUES (NULL, 'MARIA', 'F', 2);
INSERT INTO CLIENTE VALUES (NULL, 'ANDRESSA', 'F', 3);
INSERT INTO CLIENTE VALUES (NULL, 'BRUNO', 'M', 4);
INSERT INTO CLIENTE VALUES (NULL, 'CARLA', 'F', 5);
INSERT INTO CLIENTE VALUES (NULL, 'DANIEL', 'M', 6);
INSERT INTO CLIENTE VALUES (NULL, 'EVERTON', 'M', 7);
INSERT INTO CLIENTE VALUES (NULL, 'FABIOLA', 'F', 8);
INSERT INTO CLIENTE VALUES (NULL, 'GUSTAVO', 'M', 9);
INSERT INTO CLIENTE VALUES (NULL, 'HIAGO', 'M', 10);

INSERT INTO TELEFONE VALUES (NULL, 'CEL', '91827-5221', 1);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '82736-6132', 2);
INSERT INTO TELEFONE VALUES (NULL, 'COM', '73645-7043', 3);
INSERT INTO TELEFONE VALUES (NULL, 'COM', '64554-8954', 4);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '55463-9865', 5);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '46372-1776', 6);
INSERT INTO TELEFONE VALUES (NULL, 'RES', '37281-2687', 7);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '28192-3598', 8);
INSERT INTO TELEFONE VALUES (NULL, 'CEL', '19213-4409', 9);
INSERT INTO TELEFONE VALUES (NULL, 'COM', '55555-5555', 10);

---------------------- \\ ----------------------

-- TRIGGERS

-- A TRIGGER IS A PROGRAMMED PROCEDURE AUTOMATICALLY INITIATED BY A PRE-DETERMINED ACTION (INSERT/DELETE/UPDATE)
CREATE TRIGGER TRIGGER_NAME
BEFORE/AFTER INSERT/DELETE/UPDATE ON TABLE_NAME
FOR EACH ROW
BEGIN
	QLQ COMANDO SQL
END

-- WE CAN'T HAVE 2 TRIGGERS LOOKING AT THE SAME MOMENT IN THE SAME TABLE
-- WE CAN HAVE ONE TRIGGER FOR EACH MOMENT, BF/AF INSERT, BF/AF UPDATE, BF/AF DELETE
-- OLD - ALREADY EXISTS
-- NEW - WILL EXISTS
CREATE DATABASE AULA40;
USE AULA40;

CREATE TABLE USUARIO(
	IDUSUARIO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30),
	SENHA VARCHAR(100)
);

CREATE TABLE BKP_USUARIO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDUSUARIO INT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30)
);

DELIMITER $

CREATE TRIGGER BACKUP_USER
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN
	INSERT INTO BKP_USUARIO 
	VALUES(NULL, OLD.IDUSUARIO, OLD.NOME, OLD.LOGIN);
END $

DELIMITER ;

INSERT INTO USUARIO VALUES (NULL, 'ANDRADE', 'ANDRADE2009', 'HEXACAMPEAO');
DELETE FROM USUARIO
WHERE IDUSUARIO = 1;

---------------------- \\ ----------------------

-- TRIGGERS FOR BACKUP DATABASES

-- DOING A LOGICAL BACKUP \/
CREATE DATABASE LOJA;
USE LOJA;
CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

CREATE DATABASE BACKUP;
USE BACKUP;
CREATE TABLE BKP_PRODUTO(
	IDBKP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

USE LOJA;

INSERT INTO BKP_PRODUTO VALUES (NULL, 1000, 'TESTE', 0.0);  --ASSIM NAO É POSSIVEL ENVIAR P/ OUTRO BANCO
INSERT INTO BACKUP.BKP_PRODUTO VALUES (NULL, 1000, 'TESTE', 0.0);  --ASSIM É POSSÍVEL ENVIAR PARA OUTRO BANCO

DELIMITER $
CREATE TRIGGER BACKUP_PRODUTO
BEFORE INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO 
	VALUES (NULL, 
	        NEW.IDPRODUTO,
			NEW.NOME,
	        NEW.VALOR);
END
$
DELIMITER ;

INSERT INTO PRODUTO VALUES (NULL, 'LIVRO MODELAGEM', 50.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO BI', 80.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO ORACLE', 70.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO SQL SERVER', 100.00);

SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

DELIMITER $
CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO 
	VALUES (NULL, 
	       OLD.IDPRODUTO, 
		   OLD.NOME,
		   OLD.VALOR);
END
$
DELIMITER ;

DELETE FROM PRODUTO
WHERE IDPRODUTO = 2;

SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

DROP TRIGGER BACKUP_PRODUTO;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO
AFTER INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO 
	VALUES (NULL, 
	       NEW.IDPRODUTO, 
		   NEW.NOME,
		   NEW.VALOR);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES (NULL, 'LIVRO C#', 100.00);

SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

ALTER TABLE BACKUP.BKP_PRODUTO
ADD EVENTO CHAR(1);

SELECT * FROM BACKUP.BKP_PRODUTO;

DROP TRIGGER BACKUP_PRODUTO_DEL;

DELIMITER $
CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(
		NULL,
		OLD.IDPRODUTO,
		OLD.NOME,
		OLD.VALOR,
		'D'
	);
END
$

DELIMITER ;

DELETE FROM PRODUTO
WHERE IDPRODUTO = 4;

SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

DELIMITER $
CREATE TRIGGER BACKUP_PRODUTO_INS
BEFORE INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(
		NULL,
		NEW.IDPRODUTO,
		NEW.NOME,
		NEW.VALOR,
		'I'
	);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES (NULL, 'LIVRO ATA', 50.00);

SELECT * FROM PRODUTO;
SELECT * FROM BACKUP.BKP_PRODUTO;

-- TRIGGER FOR AUDITORSHIP
DROP DATABASE LOJA;
DROP DATABASE BACKUP;
CREATE DATABASE LOJA;
CREATE DATABASE BACKUP;

SELECT CURRENT_USER(); -- WHO
SELECT NOW();          -- WHEN

USE BACKUP;
CREATE TABLE BKP_PRODUTO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR_ORIGINAL FLOAT(10,2),
	VALOR_ALTERADO FLOAT(10,2),
	DATA DATETIME,
	USUARIO VARCHAR(30),
	EVENTO CHAR(1)
);

USE LOJA;
CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

INSERT INTO PRODUTO VALUES (NULL, 'LIVRO MODELAGEM', 50.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO BI', 80.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO ORACLE', 70.00);
INSERT INTO PRODUTO VALUES (NULL, 'LIVRO SQL SERVER', 100.00);

DELIMITER $

CREATE TRIGGER AUDIT_PROD
AFTER UPDATE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,
	                               OLD.IDPRODUTO,
								   OLD.NOME,
								   OLD.VALOR,
								   NEW.VALOR,
								   NOW(),
								   CURRENT_USER(),
								   'U'
);
END
$

DELIMITER ;

UPDATE PRODUTO
SET VALOR = 110.00
WHERE IDPRODUTO = 4;

---------------------- \\ ----------------------

-- DATABASE SELF-RELATIONSHIP - MODELING

CREATE DATABASE AULA44;
USE AULA44;

CREATE TABLE CURSOS(
	IDCURSO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	HORAS INT,
	VALOR FLOAT(10,2),
	ID_PREREQ INT
);

ALTER TABLE CURSOS
ADD CONSTRAINT FK_PREREQ
FOREIGN KEY(ID_PREREQ) REFERENCES CURSOS(IDCURSO);

/*
-- IN SOME CASES \/
-- INSERT THIS COURSE BEFORE THE CONSTRAINTS
INSERT INTO CURSOS VALUES (1,'SEM PRE REQ', 0, 0.0, NULL);
*/

INSERT INTO CURSOS VALUES (NULL, 'BD RELACIONAL', 20, 400.00,NULL);
INSERT INTO CURSOS VALUES (NULL, 'BUSINESS INTELLIGENCE', 40, 800.00, 1);
INSERT INTO CURSOS VALUES (NULL, 'RELATORIOS AVANCADOS', 20, 600.00, 2);
INSERT INTO CURSOS VALUES (NULL, 'LOGICA DE PROGRAMAÇÃO', 20, 400.00,NULL);
INSERT INTO CURSOS VALUES (NULL, 'RUBY', 30, 500.00, 4);

SELECT * FROM CURSOS;
SELECT NOME, VALOR, HORAS, IFNULL(ID_PREREQ, 'SEM REQ') AS REQUISITO
FROM CURSOS;

SELECT C.NOME AS CURSO, 
       C.VALOR AS VALOR, 
	   C.HORAS AS CARGA, 
	   IFNULL(P.NOME, '---') AS PREREQ
FROM CURSOS C
INNER JOIN CURSOS P
ON P.IDCURSO = C.ID_PREREQ;

SELECT C.NOME AS CURSO, 
       C.VALOR AS VALOR, 
	   C.HORAS AS CARGA, 
	   IFNULL(P.NOME, '---') AS PREREQ
FROM CURSOS C
LEFT JOIN CURSOS P
ON P.IDCURSO = C.ID_PREREQ;

---------------------- \\ ----------------------

-- INTRODUCTION TO CURSORS

-- CURSOR É UTILIZADO PARA FAZER APLICAÇÕES MATEMÁTICAS MAIS COMPLEXAS QUE UM SQL SIMPLES NÃO CONSEGUE FACILMENTE
-- CURSOR É UM REGISTRO VAI PARA A MEMÓRIA RAM, E PODE COMPROMETER O DESEMPENHO DO SERVIDOR
-- ALOCA OS REGISTROS DENTRO DO VETOR/CURSOR NA MEMÓRIA RAM


CREATE DATABASE CURSORES;
USE CURSORES;

CREATE TABLE VENDORES(
	IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(),
	JAN INT,
	FEV INT,
	MAR INT
);

INSERT INTO VENDEDORES VALUES(NULL,'MAFRA', 32432, 242334, 574545);
INSERT INTO VENDEDORES VALUES(NULL,'CLARA', 65465, 65443, 653454);
INSERT INTO VENDEDORES VALUES(NULL,'JOAO', 12432, 65356, 8756);
INSERT INTO VENDEDORES VALUES(NULL,'LILIAN', 4567, 9676, 8765);
INSERT INTO VENDEDORES VALUES(NULL,'ANTONIO', 3467, 68756, 99765);
INSERT INTO VENDEDORES VALUES(NULL,'GLORIA', 54786, 76889, 7098);


